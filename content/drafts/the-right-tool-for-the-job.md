+++
title = "The right tool for the job"
author = "hds"
date = "2022-02-21"
+++

The old (and very tired) saying goes, “always use the right tool for the job.”

This adage is sometimes (often?) invoked by engineers advocating adding yet another technology to their stack.

This tool is the best at what it does, therefore it’s what we should use.

You don’t want to use anything but the right tool for the job, right?

Of course, there is more to “best” and “the job” than that.

What if the team already has experience with other (not-the-right) tools that do the same job adequately?

What if the right tool requires adding a large number of dependencies to your project?

What if the right tool is another language?

What if the team already deals with too many languages for its size?

What if this other language has (anecdotal) evidence of a steep learning curve?

This is why Rust sounded like it should be categorised as not being right for the job.

But…

What if the whole team enjoys Rust?

What if Rust is the first language that the whole team feels that they can contribute in?

What if Rust isn’t is hard to get started with as we feared?

What if Rust is what finally joins what used to be 2 separate teams?

Basically, what if “the job” was making what used to be two separate teams finally feel like one?

Of course we didn’t know that at the time, but how we chose Rust is a story for another day.
